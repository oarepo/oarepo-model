#
# Copyright (c) 2025 CESNET z.s.p.o.
#
# This file is a part of oarepo-model (see http://github.com/oarepo/oarepo-model).
#
# oarepo-model is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.
#
import importlib.abc
import importlib.resources.abc
import importlib.util
from pathlib import Path, PurePosixPath
import sys
from importlib.metadata import Distribution, DistributionFinder
from types import SimpleNamespace
from typing import Optional

from .model import InvenioModel


class ModelDistribution(Distribution):
    def __init__(self, model: InvenioModel, namespace: SimpleNamespace):
        self.model = model
        self.namespace = namespace

    def read_text(self, filename) -> Optional[str]:
        if filename == "METADATA":
            return f"""
Metadata-Version: 2.1
Name: runtime-models-{self.model.name}
Version: {self.model.version}

..
    Copyright (C) 2025 CESNET z.s.p.o.

    This file has been generated by the OAREPO model system.
    """.strip()
        return None

    def locate_file(self, path):
        """
        Model does not have any files to locate.
        """
        raise NotImplementedError("Not implemented")

    @property
    def entry_points(self):
        return self.namespace.entry_points

    @property
    def files(self) -> list:
        ret = []
        for file_name, file_content in self.namespace.__files__.items():
            ret.append(
                InMemoryPath(
                    f"runtime_models_{self.model.name}/{file_name}", file_content
                )
            )

        return ret


class InMemoryPath(PurePosixPath):
    def __init__(self, path: str, file_content: str | None = None) -> None:
        super().__init__(path)
        self.file_content = file_content

    def read_text(self, encoding: str = "utf-8") -> str:
        if self.file_content is None:
            raise ValueError("Can not read file without content")
        return self.file_content

    def read_binary(self) -> bytes:
        if self.file_content is None:
            raise ValueError("Can not read file without content")
        return self.file_content.encode("utf-8")


def locate_file(namespace, name):
    name_list = name.split(".")[1:]
    pth = None
    for n in name_list:
        if pth is not None:
            pth = pth / n
        else:
            pth = Path(getattr(namespace, n).__file__).parent

    return FileReader(pth)


class FileReader(importlib.resources.abc.TraversableResources):
    def __init__(self, pth):
        self.path = pth

    def resource_path(self, resource):
        """
        Return the file system path to prevent
        `resources.path()` from creating a temporary
        copy.
        """
        return str(self.path.joinpath(resource))

    def files(self):
        return self.path


class ModelImporter(importlib.abc.MetaPathFinder):
    def __init__(self, model: InvenioModel, namespace: SimpleNamespace):
        self.model = model
        self.namespace = namespace

    def find_spec(self, fullname, path, target=None):
        namespace = self.namespace
        if fullname == f"runtime_models_{self.model.base_name}":
            # Create a module spec dynamically

            class Loader:
                def create_module(self, spec):
                    return None

                def exec_module(self, module):
                    module.__dict__.update(namespace.__dict__)

                def get_resource_reader(self, name):
                    raise NotImplementedError(
                        "ModelImporter does not support resource "
                        "reading for the root of the generated model"
                    )

            return importlib.util.spec_from_loader(
                fullname, loader=Loader(), is_package=True
            )
        elif fullname.startswith(f"runtime_models_{self.model.base_name}."):
            # create an empty spec for now but will need to be filled later

            submodule = fullname[len(f"runtime_models_{self.model.base_name}.") :]
            submodule_root = submodule.split(".")[0]

            if hasattr(namespace, submodule_root):

                class Loader:
                    def create_module(self, spec):
                        return None

                    def exec_module(self, module):
                        module.__dict__.update(
                            getattr(namespace, submodule_root).__dict__
                        )

                    def get_resource_reader(self, name):
                        return locate_file(namespace, name)

            else:

                class Loader:
                    def create_module(self, spec):
                        return None

                    def exec_module(self, module):
                        pass

                    def get_resource_reader(self, name):
                        return locate_file(namespace, name)

            return importlib.util.spec_from_loader(
                fullname, loader=Loader(), is_package=True
            )

        return None  # Let other finders handle it

    def find_distributions(self, context: DistributionFinder.Context):
        """
        Find distributions.

        Return an iterable of all Distribution instances capable of
        loading the metadata for packages matching the ``context``,
        a DistributionFinder.Context instance.
        """
        if not context.name or context.name.lower().replace(
            "-", "_"
        ) == f"runtime_models_{self.model.name}".replace("-", "_"):
            return [ModelDistribution(self.model, self.namespace)]
        return []


def register_model(model: InvenioModel, namespace: SimpleNamespace):
    """
    Register the model importer to the meta path.
    This allows dynamic loading of the model based on its configuration.
    """

    # prevent multiple registrations of the same model
    for importer in sys.meta_path:
        if isinstance(importer, ModelImporter) and importer.model == model:
            return

    # add the model importer to the meta path
    importer = ModelImporter(model, namespace)
    sys.meta_path.insert(0, importer)


def unregister_model(model: InvenioModel, namespace: SimpleNamespace):
    """
    Unregister the model importer from the meta path.
    This allows cleanup of the model registration.
    """
    for i, importer in enumerate(sys.meta_path):
        if isinstance(importer, ModelImporter) and importer.model == model:
            del sys.meta_path[i]
            return

    # If we reach here, the model was not registered
    raise ValueError(f"Model {model.name} is not registered.")
