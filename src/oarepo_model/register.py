#
# Copyright (c) 2025 CESNET z.s.p.o.
#
# This file is a part of oarepo-model (see http://github.com/oarepo/oarepo-model).
#
# oarepo-model is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.
#
import importlib.abc
import importlib.util
import sys
from importlib.metadata import Distribution, DistributionFinder
from types import SimpleNamespace
from typing import Optional

from .model import InvenioModel


class ModelDistribution(Distribution):
    def __init__(self, model: InvenioModel, namespace: SimpleNamespace):
        self.model = model
        self.namespace = namespace

    def read_text(self, filename) -> Optional[str]:
        if filename == "METADATA":
            return f"""
Metadata-Version: 2.1
Name: runtime-models-{self.model.name}
Version: {self.model.version}

..
    Copyright (C) 2025 CESNET z.s.p.o.

    This file has been generated by the OAREPO model system.
    """.strip()
        return None

    def locate_file(self, path):
        """
        Model does not have any files to locate.
        """
        raise NotImplementedError("Not implemented")

    @property
    def entry_points(self):
        return self.namespace.entry_points

    @property
    def files(self):
        return []


class ModelImporter(importlib.abc.MetaPathFinder):
    def __init__(self, model: InvenioModel, namespace: SimpleNamespace):
        self.model = model
        self.namespace = namespace

    def find_spec(self, fullname, path, target=None):
        namespace = self.namespace
        if fullname == f"runtime_models_{self.model.base_name}":
            # Create a module spec dynamically

            class Loader:
                def create_module(self, spec):
                    return None

                def exec_module(self, module):
                    module.__dict__.update(namespace.__dict__)

            return importlib.util.spec_from_loader(
                fullname, loader=Loader(), is_package=True
            )
        elif fullname.startswith(f"runtime_models_{self.model.base_name}."):
            # create an empty spec for now but will need to be filled later

            submodule = fullname[len(f"runtime_models_{self.model.base_name}.") :]
            submodule_root = submodule.split(".")[0]

            if hasattr(namespace, submodule_root):

                class Loader:
                    def create_module(self, spec):
                        return None

                    def exec_module(self, module):
                        module.__dict__.update(
                            getattr(namespace, submodule_root).__dict__
                        )

            else:

                class Loader:
                    def create_module(self, spec):
                        return None

                    def exec_module(self, module):
                        pass

            return importlib.util.spec_from_loader(
                fullname, loader=Loader(), is_package=True
            )

        return None  # Let other finders handle it

    def find_distributions(self, context: DistributionFinder.Context):
        """
        Find distributions.

        Return an iterable of all Distribution instances capable of
        loading the metadata for packages matching the ``context``,
        a DistributionFinder.Context instance.
        """
        return [ModelDistribution(self.model, self.namespace)]


def register_model(model: InvenioModel, namespace: SimpleNamespace):
    """
    Register the model importer to the meta path.
    This allows dynamic loading of the model based on its configuration.
    """

    # prevent multiple registrations of the same model
    for importer in sys.meta_path:
        if isinstance(importer, ModelImporter) and importer.model == model:
            return

    # add the model importer to the meta path
    importer = ModelImporter(model, namespace)
    sys.meta_path.insert(0, importer)
